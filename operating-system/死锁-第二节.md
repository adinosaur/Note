死锁-第二节
=======

本节主要归纳解决死锁的各种方法。由死锁第一节可知，主要有四种策略来解决死锁：

1. 鸵鸟算法。
2. 死锁检测并恢复。
3. 仔细对资源分配，动态地避免死锁。
4. 通过破坏引起死锁的4个必要条件之一，防止死锁的发生。

本节详细讨论以上这几种方法。

##1. 鸵鸟算法
虽然名字听上去很高大上，但其实这方法就是像鸵鸟一样把头埋在沙子里假装看不到问题。对于有些系统发生死锁的概率很低，没有必要专门为其改变固有的工作方式。

##2. 死锁检测和恢复
这种方法不阻止死锁的发生。我们要做的是，当检测出死锁发生了找一个办法将其恢复。
那么问题来了，我们怎么检测出系统发生死锁呢？（《现代操作系统 第三版》 p249-p251）

###死锁检测
* 每种类型一个资源的死锁检测。（判断一个有向图是否存在环）
* 每种类型多个资源的死锁检测。

对于死锁检测的时机可以从几个方面去考虑。比如可以在每次分配资源的时候考虑，但这样做会占有昂贵的CPU资源（《现代操作系统 第三版》P251）。又或者可以每隔K分钟检测一次，或是当CPU使用率降低到某一个阀值时候进行检测。因为当死锁进程达到一定数量，没有多少进程在实际运行，CPU往往会经常空闲。

###死锁恢复
* 利用抢占恢复。
* 通过杀死进程恢复。

##3. 谨慎分配资源，动态避免死锁
首先引入安全状态和不安全状态这两个概念。对于一个系统，如果这个系统的所有进程都请求对资源的最大需求，此时仍然存在一种调度序列使得每一个进程都能运行完毕。对于这中系统我们说是状态安全的。

###银行家算法
解决该问题的算法是银行家算法。银行家算法分为，单个资源的银行家算法和多个资源的银行家算法。其中前者可看作是后者的一个简单版。这个算法的核心就是对于每次资源分配，我们都需要考虑这次分配会不会导致系统进入不安全的状态。如果是则不满足请求（延迟该次请求），如果不是则满足该次请求。

那么，银行家算法中如何检测一个状态是否是安全的呢？简单来说，我们通过模拟操作系统的运行，观察系统中的所有进程是否都能被运行完毕，如果是则是状态安全的。（参考《现代操作系统 第三版》255页）

需要说明的是，银行家算法虽然很具有意义但缺乏实用价值。因为很少有进程在运行前便知道需要的资源的最大值。实际中很少有系统通过银行家算法来避免死锁。

##4. 通过破坏死锁四要素，预防死锁
死锁产生的四个必要的条件：

1. 互斥。
2. 占有和等待。
3. 不可抢占。
4. 环路等待。

###破坏互斥
比如说，创建一个专门负责打印的打印机守护进程。整个操作系统只有它可以请求打印机的资源，由于它本身不会请求别的资源，所以系统绝不会因为打印机产生死锁。
这里有个设计思路，尽可能做到尽可能少的进程可以请求真正的资源。

###破坏占有和等待
只要禁止已经持有资源的进程再等待其它资源便可。
具体的实现可以这样子做，规定所有的进程需要在开始执行前请求所需的全部资源。如果所需的所有资源都能被满足则分配资源，并运行该进程，否则挂起该进程。但是很多进程是运行时才知道需要多少资源的。

###破坏不可抢占

###破坏环路等待
将所有的资源都统一编号。申请资源的规则是：进程可以在任何时候提出资源请求，但是所有请求必须是按照资源编号的顺序（升序）。假设进程需要两个资源，资源A和资源B（其中资源编号A<B）。在申请时必须先申请A然后再申请B。若按此规则，系统一定不会出现死锁。


##参考资料
1. 《现代操作系统 第三版》第6章 死锁