文件系统
=====

###引入问题
内存在断电后存储的信息便会丢失，因此当我们需要长期存储一些东西的话，我们会把信息存储在磁盘中。
磁盘可以看作是一个固定块大小的线性序列，支持两种基本的操作：

1. 读块k。
2. 写块k。

现在有了磁盘后（假设磁盘的块大小为4k），当我们想要保存一个大小为10k的数据时，我们要怎么做呢？

* 首先从磁盘中找出3个空闲块（块一定是整数分配的，对于块大小为4k，想要存10k的数据要分配3个块，虽然实际上的数据只是占2.5块大小，因此浪费了0.5个块存储空间），然后将数据写入这3个块中。

* 当我们想要读回之前写的数据时，必须知道数据放在哪些块中，而且这些块的数据的顺序是怎样的。这些都是磁盘的直接使用者需要考虑的问题。

###文件系统与文件的概念

显然这样做是很麻烦的，每次使用磁盘时用户必须自己把控制磁盘中块号的分配这是一件很不科学的事情。
而我们想要的磁盘是这样子工作的：我把我想要存的数据交给磁盘，我也能方便地从磁盘中取回我存储的数据。而具体的存储细节我是不需要操心的。做这事的就是文件系统，像内存管理中对底层物理内存抽象出一个虚拟的地址空间一样，文件系统是对磁盘块号抽象得出文件的概念。


###文件的存储
通过文件系统，我们可以很方便的存储一个文件。那么文件中的数据又是如何被分配到磁盘块上的呢？
文件存储最关键的是记录文件的各个部分分别用到哪些磁盘块。

####1. 连续分配
这种方法最简单。在块大小为1kb的磁盘上，50kb的文件要分配50个连续的块。优点有两个：

1. 对于文件只需要记住其起始块号和使用的块数，实现简单。
2. 读写效率高，由于块都是连续因此或许只需要1次的寻道，旋转等操作。

但是连续分配也有相当的明显的缺点。随着时间的推移，磁盘会变得很破碎。为了解决这个问题可以压缩磁盘，但是这样做的代价是很高的，因为需要移动全部的后续磁盘块。

虽然有缺点，但是对于哪些初始分配后就不会改变的存储，连续分配是最适合不过了（例如CD-ROM）。

####2. 链表分配
第二种方法是为每一个文件构造一个链表，链表中的每一个结点（块号）的尾部存放指向下一个结点（块号）的指针。而文件最后一个磁盘块的下一个块号放置一个结束标志即可。可以看出这种存储方式完全没有磁盘碎片的问题，因此可以充分的利用磁盘。

但是链表存储对于顺序读取文件还适合，但如果要求随机地访问文件就很勉强了。因为文件只是保存了头结点（磁盘块）的指针，因此操作系统必须每次都从头开始访问，逐个遍历最终找到想要读取的磁盘块。所以这种结构文件不支持随机存取。

一个优化策略，就是在内存中维护一个所有磁盘块号的表。表的key是磁盘块号，value是下一个磁盘块号。这样做的好处是能很快的找出一个文件占用的所有磁盘块号。但是相应的，要在内存为每一个磁盘块号占用一个单元的存储，因此内存中占用的空间和磁盘的大小成倍数的增长。

####3. i节点（index node）
文件系统为每一个文件分配一个i节点的数据结构，其中列出了文件的属性和文件所包含的磁盘块号（块地址）。
相比于内存中用表的结构，使用i节点的优势在于，只有在对应文件打开时，其i节点才存在在内存中。

有一个问题，i节点的大小是固定的，那么如果文件占用的磁盘数超过i节点所能容纳的数目怎么办？
有很多方法可以解决这个问题，比较简单的是i结点最后一个磁盘地址位置不直接指向文件所占用的磁盘块，而是作为一个二级地址指向一个包含磁盘块地址的磁盘块（类似于指针的指针）。